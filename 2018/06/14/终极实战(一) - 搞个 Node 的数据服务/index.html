<!doctype html>
<html>
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>青湛</title>
  <meta name="author" content="青湛" />
  <meta name="keywords" content="青湛,博客,qingzhan,mintsweet,blog" />
  <meta name="description" content="青湛's Blog" />
  
  <link rel="icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://cdn.tailwindcss.com"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

  <body class="relative pb-8 min-h-screen border-t-2 border-black">
    <header class="shadow-sm bg-white">
  <div class="flex justify-between mx-auto max-w-3xl py-2">
    <div class="flex items-center">
      <div class="w-8 h-8">
        <img src="/logo.svg" alt="" />
      </div>
      <h1 class="ml-4">青湛</h1>
    </div>
    <ul class="flex items-center justify-end">
      
      <li class="ml-4"><a href="/" title="Home">Home</a></li>
      
      <li class="ml-4"><a href="/about/" title="About">About</a></li>
      
      <li class="ml-4"><a href="/archives/" title="Archives">Archives</a></li>
      
      <li class="ml-4"><a href="/tags/" title="Tags">Tags</a></li>
      
    </ul>
  </div>
</header>

    <main>
      <div class="mx-auto max-w-3xl"><div class="py-8 post">
  <h1 class="text-3xl font-semibold mb-1">终极实战(一) - 搞个 Node 的数据服务</h1>
  <div class="flex items-center mb-4 text-sm">
    <span class="pl-2 text-slate-400">2018-06-14</span>
    <span class="mx-4">|</span>
    
    <div class="flex items-center">
       <a href="/tags/%E6%8A%80%E6%9C%AF/" title="#技术" class="mr-2 text-slate-400">#技术</a>  <a href="/tags/JavaScript/" title="#JavaScript" class="mr-2 text-slate-400">#JavaScript</a> 
    </div>
    
  </div>
  <article class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我今年二月的时候就准备筹划一整个<code>React</code>的学习系列，但是发现自己真的是不够强，理解还不够深刻，加上真的没有理想的那么多时间，所以直接简化到这几篇闲来无事系列。</p>
<p>本篇用<code>Koa</code> 、 <code>MongoDB</code> 和 <code>Redis</code> 搞一个以<code>json</code>通信的服务器，用于之后所有客户端的接口服务！</p>
<span id="more"></span>

<p><strong><a target="_blank" rel="noopener" href="https://github.com/mintsweet/practice/wiki/API">API详情</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/mintsweet/practice/blob/master/packages/server/README.md">README</a></strong></p>
<h2 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h2><p>整个系统在设计下来之后，发现也不是想象的那么简单，但是也算不上复杂，大体上就是一个以发布话题为主体，围绕展开的功能。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>整个数据结构分为五个大块，分别是<code>用户</code>、<code>话题</code>、<code>回复</code>、<code>消息</code>和<code>行为</code>。前三个都好说，<code>消息</code>其实也很好理解，比如一个用户关注了另一个用户，被关注的人肯定是有提醒的，主要说一下<code>行为</code>，为什么要叫行为呢？主要是用户的动作有多种，比如收藏、点赞等等，我不想为每一种行为都单独设定一个数据结构，它们的结构也完全可以类似，所以整体就叫做<code>行为</code>了。</p>
<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>大部分内容还是容易理解，我就说一下差不多写完以后才发现错了好多的地方，第一个就是数据层没有单独提出来，也就是操作数据库的部分还是封在了<code>controller</code>里面，但其实这样使得整个<code>controller</code>层中的代码很臃肿，后来我发现我的积分制度居然忘记加了，就开始一个文件一个文件的找每次需要增加积分的地方修改，其实如果抽离了数据层，修改起来就会简单许多。</p>
<p>还有一个容易错的地方，由于我把整个用户行为都封在了一个数据结构中，以<code>type</code>字段区分，但是行为与行为直接还是有些许差异的，如果处理不当，就会看起来很混乱，这也是我不想看到的情况。</p>
<h2 id="目录设计"><a href="#目录设计" class="headerlink" title="目录设计"></a>目录设计</h2><p>目录其实完全可以按照个人喜好来规划目录，但是我还是觉得写代码嘛，越规范越好，但是我也不是说我这种目录结构就是最规范的…..只是做个参考，遵循<code>MVC</code>模式，只是这里我们的服务只负责数据，不负责视图，所以就只剩<code>MC</code>，模型和控制器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── sever</span><br><span class="line">│   ├──  __test__ （单元测试）</span><br><span class="line">│   ├──  controllers （控制器）</span><br><span class="line">│   ├──  db （数据库连接和操作）</span><br><span class="line">│   ├──  logs （日志）</span><br><span class="line">│   ├──  middlewares （中间件）</span><br><span class="line">│   ├──  models （数据模型）</span><br><span class="line">│   ├──  proxy （数据库实际操作）</span><br><span class="line">│   ├──  uploads （文件上传临时目录）</span><br><span class="line">│   ├──  utils （工具函数）</span><br><span class="line">│   ├──  app.js （入口）</span><br><span class="line">│   └──  router.js （路由文件）</span><br></pre></td></tr></table></figure>

<p>这个树形结构基本上已经把整个目录描述出来了，写过<code>Node</code>的小伙伴可能一眼就能猜出每个目录的作用了，没有写过也没关系，让我慢慢说。</p>
<h2 id="来一个完整的API"><a href="#来一个完整的API" class="headerlink" title="来一个完整的API"></a>来一个完整的API</h2><p>每个地方的拆分来说的话，对于阅读其实没有那么友好，所以先走一个完整的流程可以帮助我们更好更快的<br>去理解一次请求所经历的所有地方。</p>
<h3 id="开启一个服务"><a href="#开启一个服务" class="headerlink" title="开启一个服务"></a>开启一个服务</h3><p>没得说，首先我们肯定是需要一个能够接受到客户端请求的服务器，使用<code>Koa</code>能够快速搭建服务器，这里我就直接贴出更复杂完整一些的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">&#x27;koa-body&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> koaJwt = <span class="built_in">require</span>(<span class="string">&#x27;koa-jwt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">jwt</span>: &#123; <span class="variable constant_">SECRET</span> &#125;, <span class="variable constant_">SERVER_PORT</span>, <span class="variable constant_">FILE_LIMIT</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../config&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;./utils/logger&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ErrorHandler</span> = <span class="built_in">require</span>(<span class="string">&#x27;./middlewares/error-handler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 mongodb</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./db/mongodb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line">app</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title function_">koaBody</span>(&#123;</span><br><span class="line">    <span class="attr">multipart</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">formidable</span>: &#123;</span><br><span class="line">      <span class="attr">uploadDir</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/uploads`</span>,</span><br><span class="line">      <span class="attr">keepExtensions</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">multiples</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">maxFieldsSize</span>: <span class="variable constant_">FILE_LIMIT</span>, <span class="comment">// 限制上传文件大小为 512kb</span></span><br><span class="line">      <span class="title function_">onFileBegin</span>(<span class="params">name, file</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dir = path.<span class="title function_">dirname</span>(file.<span class="property">path</span>);</span><br><span class="line">        file.<span class="property">path</span> = path.<span class="title function_">join</span>(dir, file.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title function_">koaJwt</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="variable constant_">SECRET</span>,</span><br><span class="line">    <span class="attr">passthrough</span>: <span class="literal">true</span></span><br><span class="line">  &#125;))</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">ErrorHandler</span>.<span class="property">handleError</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// router</span></span><br><span class="line">app</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="property">rt</span>)</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="property">v1</span>)</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="property">v2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 404</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;请求的API地址不正确或者不存在&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handle</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> logger.<span class="title function_">error</span>(err)); <span class="comment">// 记录服务器错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">module</span>.<span class="property">parent</span>) app.<span class="title function_">listen</span>(<span class="variable constant_">SERVER_PORT</span>);</span><br></pre></td></tr></table></figure>

<p>我在上述代码中暂时注释了跨域和域名拦截的代码，方便我测试。为了帮助大家更好的理解其中的流程，我把流程写了下来。</p>
<ol>
<li>引入依赖</li>
<li>引入自写<code>mongodb</code>模块，连接数据库</li>
<li>实例化<code>Koa</code>为<code>app</code>，同时暴露<code>app</code>方便单元测试</li>
<li>引入中间件，包括请求体解析，<code>jwt</code>和自写错误处理</li>
<li>引入路由</li>
<li>处理请求路径不在路由中的<code>404</code></li>
<li>记录服务器错误</li>
<li>监听配置端口，开启服务</li>
</ol>
<p>对于上述代码如果还不是很清楚，可以对照流程和代码一起看，我相信看起来应该没有这么复杂了吧！</p>
<h3 id="设置一个路由地址"><a href="#设置一个路由地址" class="headerlink" title="设置一个路由地址"></a>设置一个路由地址</h3><p>一起来思考一下，现在我们的服务已经开启了，客户端如何请求，服务器又如何知道客户端请求的是哪一个接口呢？很明显是通过路由(也就是url)来判断的，我们现在以一个<strong>登录接口</strong>来说明。</p>
<p>在入口文件<code>app.js</code>中，我们引用了<code>router.js</code>，这个文件就是路由的匹配文件，一起来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="built_in">require</span>(<span class="string">&#x27;./controllers/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>, <span class="title class_">User</span>.<span class="property">signin</span>); <span class="comment">// 登录</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">rt</span>: router.<span class="title function_">routes</span>(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我删掉了其他<code>API</code>的路由，只留下了<strong>登录</strong>一个，这样看起来是不是很简单了，还是来理一下整个流程：</p>
<ol>
<li>客户端发起一个请求，请求地址为<code>/signin</code>。</li>
<li>服务器接收到这个请求并去匹配路由。</li>
<li>找到匹配路由的处理方法交给控制器<code>User</code>的<code>signin</code>方法处理。</li>
</ol>
<p>可以看得出来最后请求会交个控制器去处理，也就是我们的逻辑代码。</p>
<h3 id="控制器处理这个请求"><a href="#控制器处理这个请求" class="headerlink" title="控制器处理这个请求"></a>控制器处理这个请求</h3><p>到了这一步，也就是最后一步，这个控制器存储了很多个方法，分别处理不同的请求地址，这里我们只看其中<code>signup</code>方法，我像之前那样只留下<code>signup</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Base</span> = <span class="built_in">require</span>(<span class="string">&#x27;./base&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">jwt</span>: &#123; <span class="variable constant_">SECRET</span>, <span class="variable constant_">EXPIRSE</span>, <span class="variable constant_">REFRESH</span> &#125;, <span class="attr">qn</span>: &#123; <span class="variable constant_">DONAME</span> &#125; &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../../config&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserProxy</span> = <span class="built_in">require</span>(<span class="string">&#x27;../proxy/user&#x27;</span>); <span class="comment">// 关于 User 表的数据操作封装</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">signup</span> = <span class="variable language_">this</span>.<span class="property">signup</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">signin</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; email, password &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验邮箱</span></span><br><span class="line">    <span class="keyword">if</span> (!email || !<span class="regexp">/^([A-Za-z0-9_\-.])+@([A-Za-z0-9_\-.])+\.([A-Za-z]&#123;2,4&#125;)$/</span>.<span class="title function_">test</span>(email)) &#123;</span><br><span class="line">      ctx.<span class="keyword">throw</span>(<span class="number">400</span>, <span class="string">&#x27;邮箱格式错误&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title class_">UserProxy</span>.<span class="title function_">getOne</span>(&#123; email &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">      ctx.<span class="keyword">throw</span>(<span class="number">404</span>, <span class="string">&#x27;尚未注册&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isMatch = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">_comparePass</span>(password, user.<span class="property">password</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isMatch) &#123;</span><br><span class="line">      ctx.<span class="keyword">throw</span>(<span class="number">400</span>, <span class="string">&#x27;密码错误&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回JWT</span></span><br><span class="line">    <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: user.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">role</span>: user.<span class="property">role</span>,</span><br><span class="line">        <span class="attr">exp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() + <span class="variable constant_">EXPIRSE</span>,</span><br><span class="line">        <span class="attr">ref</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() + <span class="variable constant_">REFRESH</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="variable constant_">SECRET</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我没有在代码中写注释是因为我觉得里面的代码并不复杂，我直接来解析一下其中的流程。</p>
<ol>
<li>接上述流程来到<code>signin</code>方法。</li>
<li>方法接收一个参数<code>ctx</code>，这个参数是<code>Koa</code>提供的。</li>
<li>解析<code>ctx</code>参数，拿到请求体中的参数<code>email</code>和<code>password</code>。</li>
<li>校验参数是否合法。</li>
<li>根据<code>email</code>判断是否存在这个用户。</li>
<li>使用密码比较方法对比传入的<code>password</code>和数据库中的<code>password</code>是否抑制。</li>
<li>组装带有用户<code>id</code>和<code>role</code>字段的<code>jwt</code>。</li>
<li>使用<code>ctx</code>参数返回结果。</li>
</ol>
<p>到这里客户端就能接收到服务器返回的结果了，一个完整的<code>API</code>请求的整个流程也算是完成了，其他<code>API</code>请求类似，读者可以自行对号观看，接下来就说说其中比较特别的地方，<code>API</code>流程我也不再继续展开。</p>
<h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><p>本来一开始写这文的时候，还是没有这一节的，当时写代码也觉得写测试太麻烦了，也不是很熟，后来还是觉得做事情确实要好好做，还是把测试加上了，我这里依然以<strong>登录</strong>为例，带大家走一次完整测试的流程。</p>
<h3 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h3><p>一开始我本来打算以一个控制器去划分一个测试文件，后来发现一个控制器中可能有<code>N</code>个<code>API</code>，那代码不得超长了，所以后来我就以一个<code>API</code>划分一个测试文件，以注册为例，创建<code>__test__/user/signin.test.js</code>文件。</p>
<h3 id="编写一个测试用例"><a href="#编写一个测试用例" class="headerlink" title="编写一个测试用例"></a>编写一个测试用例</h3><p>书写测试能用的依赖有很多，由于我本身对测试不是很熟的原因，还是挑了使用最为广泛的<code>mocha</code>，大家也可以自行选择。下面是一个以<code>mocha</code>为例的测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;../../app&#x27;</span>).<span class="title function_">listen</span>();</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>)(app);</span><br><span class="line"><span class="keyword">const</span> should = <span class="built_in">require</span>(<span class="string">&#x27;should&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;test /api/signup&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 错误 - 密码</span></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;should / status 400 when the password is not match&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> request</span><br><span class="line">        .<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>)</span><br><span class="line">        .<span class="title function_">send</span>(&#123;</span><br><span class="line">          <span class="attr">email</span>: <span class="string">&#x27;123456@qq.com&#x27;</span>,</span><br><span class="line">          <span class="attr">password</span>: <span class="string">&#x27;a123456789&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">      res.<span class="property">text</span>.<span class="property">should</span>.<span class="title function_">equal</span>(<span class="string">&#x27;密码错误&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      should.<span class="title function_">ifError</span>(err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我大量简化了其中的代码，留下其中一个测试用例给大家参考，其实这样看起来也并不复杂对吧…所谓的测试，就是去验证返回的结果和预期的结果是否相等，比如上述登录接口是需要验证密码是否正确，而我传的是一个错误密码，所以应该返回的信息是<code>密码错误</code>。</p>
<h3 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h3><p>测试除了使用<code>mocha</code>以外，还用了<code>supertest</code>和<code>should</code>两个模块，这两个东西都用来配合<code>mocha</code>使用，它本身不提供能够直接连接服务器的东西所以用<code>supertest</code>来连接我们的服务器，<code>should</code>是断言库，所谓的断言就是判断得到的结果是否和预期一致。</p>
<h2 id="API设计规范"><a href="#API设计规范" class="headerlink" title="API设计规范"></a>API设计规范</h2><p><del>标题略微狂妄…与其说是规范，不如说是个人习惯吧。我在工作过程中也算是遇到过很多不同的<code>API</code>习惯，有些喜欢直接返回结果，失败客户端自行加入拦截器去拦截错误码，有些又喜欢自己返回是否错误的信息，我比较喜欢后者，所以关于这个服务的<code>API</code>也是这么做的。</del></p>
<p>由于改由<code>Koa</code>编写后，全部<code>API</code>均遵循<code>RESTful</code>风格，所以去除该部分内容，</p>
<h2 id="关于中间件拦截"><a href="#关于中间件拦截" class="headerlink" title="关于中间件拦截"></a>关于中间件拦截</h2><p>在客户端请求的时候，有些接口是有前置条件的，比如<strong>查看用户信息</strong>，如果没有登录，如何能够查看用户信息，所以这个时候就需要路由拦截，去校验是否有这个权限，这个服务在设计的时候有三种权限类型，分别是<code>普通用户</code>、<code>管理员</code>、<code>超级管理</code>。路由拦截定义在<code>middleware</code>里面，设置于<code>router.js</code>中，比如用户现在要请求一个<strong>查看当前用户信息</strong>的接口，来一起看一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/info&#x27;</span>, <span class="title class_">Auth</span>.<span class="property">userRequired</span>, <span class="title class_">User</span>.<span class="property">getCurrentUser</span>); <span class="comment">// 获取当前用户信息</span></span><br></pre></td></tr></table></figure>

<p>在<code>router.js</code>里面的这个接口中可以发现一个<code>Auth.userRequired</code>的方法，也就是在进入这个接口之前，会先执行这个方法，在到<code>User.getCurrentUser</code>这个方法里面去，来看看<code>Auth</code>里面的东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Auth</span> &#123;</span><br><span class="line">  <span class="comment">// 用户基础权限</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">userRequired</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = ctx.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">if</span> (!user) ctx.<span class="keyword">throw</span>(<span class="number">401</span>, <span class="string">&#x27;尚未登录&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; is_valid, token &#125; = <span class="variable language_">this</span>.<span class="title function_">_validJWT</span>(user);</span><br><span class="line">    <span class="keyword">if</span> (!is_valid) ctx.<span class="keyword">throw</span>(<span class="number">401</span>, <span class="string">&#x27;登录已过期，请重新登录&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) ctx.<span class="title function_">set</span>(<span class="string">&#x27;token&#x27;</span>, token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">Auth</span>();</span><br></pre></td></tr></table></figure>

<p>同上我没有贴上完整的代码，只贴了关于用户校验的部分，这个时候你会发现这个方法里面多了一个<code>next</code>参数，也就是如果回传回来的参数头关于<code>jwt</code>能解析并且没有过期，就会走到<code>User.getUserInfo</code>的方法里面，如果没有在这个方法里面就会抛出错误。</p>
<h2 id="数据模型的额外的事"><a href="#数据模型的额外的事" class="headerlink" title="数据模型的额外的事"></a>数据模型的额外的事</h2><p><del>这个里面没什么太多要说的，主要是看业务用到哪些表，哪些字段是弄这个东西。我单独拿出来要说的是手动生成<code>id</code>，这样做需要多出一个表结构，我命名为<code>ids</code>。</del></p>
<p><del>在初始化数据库的时候会动态的生成一条数据，这条数据也就是这个表唯一的数据，会每次将对应表的<code>id</code>加一，这种做法我是参照了<code>Github</code>一个比较厉害的人搞得，其实具体有什么优势我内心也是懵逼的(哈哈哈哈)，靠大家自行摸索了。</del></p>
<p>后来我仔细想了一下，也问了一下写后端的同事，确实好像没有必要这么搞去手动生成一个自定义的<code>id</code>，徒增工作量，所以去掉了这一部分。</p>
<p>这两天多看了一下<code>mongoose</code>的文档，做了一点细微的调整，加入一个模型插件<code>/models/plugin</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;moment/locale/zh-cn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">schema</span>) &#123;</span><br><span class="line">  schema.<span class="property">methods</span>.<span class="property">create_at_ago</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">moment</span>(<span class="variable language_">this</span>.<span class="property">create_at</span>).<span class="title function_">fromNow</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  schema.<span class="property">options</span>.<span class="property">toObject</span> = schema.<span class="property">options</span>.<span class="property">toJSON</span> = &#123;</span><br><span class="line">    <span class="title function_">transform</span>(<span class="params">doc, ret</span>) &#123;</span><br><span class="line">      ret.<span class="property">id</span> = ret.<span class="property">_id</span>;</span><br><span class="line">      ret.<span class="property">create_at</span> = <span class="title function_">moment</span>(ret.<span class="property">create_at</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret.<span class="property">update_at</span>) ret.<span class="property">update_at</span> = <span class="title function_">moment</span>(ret.<span class="property">update_at</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>);</span><br><span class="line">      <span class="keyword">delete</span> ret.<span class="property">__v</span>;</span><br><span class="line">      <span class="keyword">delete</span> ret.<span class="property">_id</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在数据查出转换的时候，生成一个<code>id</code>并且删除了<code>_id</code>和<code>__v</code>，省去了每次都需要加入查询条件，而且<code>id</code>更符合惯性的思维。同时给数据模型手动添加一个个方法<code>create_at_ago</code>，表示从创建时间到现在过了多久。</p>
<h3 id="ProtoType的存在"><a href="#ProtoType的存在" class="headerlink" title="ProtoType的存在"></a>ProtoType的存在</h3><p><del>其实<code>prototype</code>完全是可以省略的，如果你没怎么用上前面说的动态生成<code>id</code>，由于我用了动态生成<code>id</code>，也就意味着在每一个控制器中都需要一个同样的方法去生成<code>id</code>，所以就用到了这个东东，不过在这个服务里面我加入了用<code>Node</code>画图形验证码的方法。</del></p>
<p><del>生成<code>Id</code>的方法是<code>getId</code>，画图形验证码用到了<code>gd-bmp</code>库，早在去年十月的时候我就开始想搞一个<code>Node</code>能画图形验证码的库，也搜了好多，由于<code>gd-bmp</code>真的好用加上时间也没有这么空余，就直接用的别人的，不过是真的不错！！</del></p>
<p>去掉了手动去生成<code>id</code>的方法以后，我一度认为这个东东没什么用了，毕竟画验证码也只是在验证码模块中使用，并不涉及到所有的，后来我加入存用户行为和用户消息这两个结构后，又重新使用了这个东东，改为<code>controllers/base</code>，把一些公共需要的方法放入其中。</p>
<h2 id="在捋一次完整的流程"><a href="#在捋一次完整的流程" class="headerlink" title="在捋一次完整的流程"></a>在捋一次完整的流程</h2><p>看完上述你会发现其实真的不难，当然还有很多东西没有去弄，也有很多需要优化的地方，但是一个简单的能作为数据服务的服务器就这么弄出来了，写代码确实是一件很有意思的事情。整个流程再来看一下：</p>
<ol>
<li>创建对应的数据模型(就像<code>uesr</code>表)</li>
<li>创建对应的路由拦截(就像<code>/signin</code>登录一样)</li>
<li>创建处理方法(就像<code>controller/user</code>里面的<code>signin</code>方法一样)</li>
<li>开启服务</li>
<li>客户端去请求这个地址</li>
<li>客户端得到服务器的返回数据</li>
</ol>
<p>一个完整的流程就这么简单，所有其他的<code>API</code>也是这么做出来的，代码虽然我还在完善，不过大部分的<code>API</code>都已经完成了，后期也还可能在改一改，也会记录在<a target="_blank" rel="noopener" href="https://github.com/mintsweet/practice/blob/master/CHANGELOG.md">CHANGELOG</a>里面。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇作为我<strong>终极实战</strong>系列的第一篇，讲述用<code>Node</code>完整搭建一个数据服务器的过程，一次请求的完整流程，也是作为后面所有不同终端的数据服务，所以本篇的意义就是讲述一个提供服务的过程。</p>
</article>
</div>
</div>
    </main>
    <footer class="absolute bottom-2 left-0 right-0">
  <div class="mx-auto max-w-3xl flex items-center justify-between">
    <p class="text-sm">
       Copyright &copy;  2023 青湛
    </p>
    <p class="text-sm">
      Powered by
      <a href="https://hexo.io" target="_blank" class="underline">Hexo</a>
      • Theme
      <a
        href="https://github.com/mintsweet/hexo-theme-mints"
        target="_blank"
        class="underline"
        >Mints</a
      >
    </p>
  </div>
</footer>

  </body>
</html>
